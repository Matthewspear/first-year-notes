\documentclass[frontgrid]{flacards}
\usepackage{tabularx}
\usepackage[parfill]{parskip}
\usepackage{color}


\definecolor{light-gray}{gray}{0.75}

\newcommand{\frontcard}[1]{\textcolor{light-gray}{\colorbox{light-gray}{$#1$}}}
\newcommand{\backcard}[1]{#1} 

\newcommand{\flashcard}[1]{% create new command for cards with blanks
    \card{% call the original \card command with twice the same argument (#1)
        \let\blank\frontcard% but let \blank behave like \frontcard the first time
        #1
    }{%
        \let\blank\backcard% and like \backcard the second time
        #1
    }%
}

\begin{document}

\pagesetup{2}{4} 

\card{
	Where do the values that are fed into an operand come from when an
	instruction is executed using the three address style?
}{
	Memory.
	\vspace{1em}\\
	The resulting value is also copied to a destination address in memory.
}

\card{
	Why are registers faster than memory?
}{
	\begin{tabularx}{0.5\textwidth}{l X}
		- & Implemented using a flip flop or some other very fast volatile
		storage (rather than smaller, cheaper SRAM).\\
		- & Situated inside the processor, so there's less distance for the
		data to travel, which takes less time.\\
		- & Fewer of them so address decoding takes less time\\
		- & Data doesn't need to be transferred over a bus.\\
	\end{tabularx}
}

\card{
	What is the {\it one-address} style of instruction?
}{
	Where only one memory address may be used in any one instruction. The other
	operands must be registers.
}

\card{
	Describe the {\it load-store} style of instruction.
}{
	The only operations on memory are load and store operations. This means each
	instruction is very fast and very simple, but there are many instructions.
}

\card{
	How is code written in ARM Assembly run?
}{
	It is first assembled using an assembler into machine code. Then it is
	loaded into memory and executed sequentially.
}

\card{
	What is the instruction to load a value at a memory address into a register?
}{
	{\tt LDR \[register\] \[memory_address_alias\]}
}

\card{
	What is the instruction to store a value in a register to a memory address?
}{
	{\tt STR \[register\] \[memory_address_alias\]}
}

\card{
	What is the instruction to sum two numbers?
}{
	{\tt ADD \[destination_register\] \[operand_register1\] \[operand_register2\]}
}

\card{
	What is the instruction to branch upon a condition?
}{
	{\tt B \[condition\] \[branch_name\]}
}

\card{
	What does the program counter do? What register is it?
}{
	It is used to store the memory address of the next instruction to be executed.
	\vspace{1em}\\
	It's register 15.
}

\card{
	When is the {\tt DEFW} command executed. What does it do? What's its syntax?
}{
	It is executed before the program runs.
	\vspace{1em}\\
	It stores a value at a memory address and assignes the address an alias.
	\vspace{1em}\\
	{\tt \[alias\] DEFW \[value_1\], ... \[value_n\]}
}

\card{
	What does {\tt DEFB} do?
}{
    {\tt DEFB} stores a single byte in memory. If you give it a string, the
	whole string will be stored (in multiple bytes).
}

\card{
	What's the syntax of {\it DEFS}?
}{
	{\it \[alias\] DEFS \[number_of_bytes\], \[value_of_bytes\]}
}

% Up to lecture 4


% -------------------
% Methods of indexing
% -------------------
\card{
	In the following instruction, what method of indexing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1]}
}{
	This is called {\bf register-indirect addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1}.
	\\\vspace{2em}
	{\tt R1} won't be altered at all.
}

\card{
	In the following instruction, what method of indexing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, \#4]}
}{
	This is called {\bf pre-indexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + 4}.
	\\\vspace{2em}
	{\tt R1} won't be altered at all.
}

\card{
	In the following instruction, what method of indexing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, \#4]!}
}{
	This is called {\bf pre-indexed autoindexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + 4}.
	\\\vspace{2em}
	{\tt R1} will be incremented by {\tt 4} {\it before} the load operation.
}

\card{
	In the following instruction, what method of indexing is used, what will
	{\tt R0} contain and what will happen to {\tt R1}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1], \#4}
}{
	This is called {\bf post-indexed autoindexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + 4}.
	\\\vspace{2em}
	{\tt R1} will be incremented by {\tt 4} {\it after} the load operation.
}

\card{
	In the following instruction, what method of indexing is used, what will
	{\tt R0} contain and what will happen to {\tt R1} and {\tt R2}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, R2]}
}{
	This is called {\bf register-indexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + R2}.
	\\\vspace{2em}
	{\tt R1} and {\tt R2} will stay the same.
}

\card{
	In the following instruction, what method of indexing is used, what will
	{\tt R0} contain and what will happen to {\tt R1} and {\tt R2}?
	\\\vspace{2em}
	{\tt LDR	R0, [R1, R2, LSL, \#2]}
}{
	This is called {\bf scaled register-indexed addressing}.
	\\\vspace{2em}
        The value loaded into {\tt R0} will be the 32 bits stored at the memory
	address that is equal to the value in {\tt R1 + (R2 * 4)}.
	\\\vspace{2em}
	{\tt R1} and {\tt R2} will stay the same.
}

\end{document} 
