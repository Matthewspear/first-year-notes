\documentclass{article}

% Gives us lovely headers
\usepackage{fancyhdr}
% Means you don't have to put \\ to start a new line.
\usepackage[parfill]{parskip}
% For including pictures
\usepackage{graphicx}
% For line brakes in tables
\usepackage{tabularx}
% For the split environment
\usepackage{amsmath}
% For tabs in verbatim
\usepackage{moreverb}
% Gives us bigger margins on the right (and smaller on the left) for the margin
% paragraphs
\usepackage[left=2cm,
			top=3cm,
			right=5cm,
			bottom=3cm,
			marginparwidth=4cm,
			marginparsep=3mm]{geometry}

\begin{document}
% Meta
\author{Chris Williamson, Todd Davies}
\title{COMP15111 Notes}
\rhead{COMP15111 Notes}

\maketitle

{\small Note, extra space has been allocated for the right hand margin to allow
for more extensive margin notes. Also, it gives you space to make your own
annotations and perhaps try some problems of your own.}

\tableofcontents
\newpage

\section{Lecture 1: Introduction}
\subsection{A Computational Model}
The simplest, earliest, commonest, most important computational model is the \textbf{Von-Neumann Imperative Procedural Computer Model}

According to this model, a computer can:
\begin{enumerate}
	\item Store information
	\item Manipulate the stored information
	\item Make decisions depending on the stored information
\end{enumerate}

\subsection{Simple View Of A Computer}
The simplest model of a computer can be represented as:

\[
	Memory \Leftrightarrow Bus \Leftrightarrow Processor
\]

\subsubsection{Memory}
Memory is a set of locations which can hold information, such as numbers(or programs). Each memory location has a unique (numerical) address, and there are typically thousands of millions of different locations. There are various ways of depicting memory; a common one is a 'hex dump' that often looks something like this: \marginpar{\raggedright Run the command {\it hexdump} to generate hexdumps.}

\begin{tabular}{l l l}
	Address     &	Values (8 bit numbers)	&	Characters\\
	00000000	&	48 65 6c 6c 6f 0a		&	Hello.\\
\end{tabular}

Each item that is in the memory has a unique address.

\subsubsection{Bus}
A bus is a bidirectional communication path. It is able to transmit addresses and numbers between components inside the computer.

\subsubsection{Processor}
The processor obeys a sequence of instructions, commonly referred to as a program.
Historically the processor was often referred to as a CPU, however, this is inappropriate nowadays since typical processors consist of several processing cores.

\subsection{Three-address instructions}
Every kind of processor has a different set of instructions, real world examples include: Pentium, ARM and others

Each three-address instruction:
\begin{enumerate}
	\item Copies the values from any two memory locations and sends them to the processor (source operands)
	\item Copies some operation e.g. adds the copied numbers together
	\item Copies the result back from the processor into a third memory location (destination operand)
\end{enumerate}

For example, if we wanted to convert the Java code $sum = a + b;$ into a three-address instruction we would:
\begin{enumerate}
	\item Identify the two {\it source operands}: $a$ holds 2, $b$ holds 3
	\item Perform the {\it operation}: 2 + 3 = 5
	\item Let the variable $sum$ equal the answer 5. This is the {\it destination operand}
\end{enumerate}

\subsubsection{Three address example}
{\bf Question:} Convert the Java code {\it product = c * d;} into the three-address style and draw a two box view of it.

First we need to re-write the Java code in the three-address style:
\[
	product \leftarrow c * d
\]
Now we can draw the box view of it:

\begin{figure}[ht!]
	\centering
	\includegraphics[width=90mm]{two_box_model_diagram.pdf}
	\caption{An example of the two box model}
	\label{overflow}
\end{figure}

\subsubsection{Memory bottleneck}
Most processors can process instructions faster than they can be fed by memory. Each instruction in the three-address cycle requires four memory cycles:

\begin{enumerate}
    \item Fetch the instruction
    \item Read the first operand
    \item Read the second operand
    \item Write the result to memory
\end{enumerate}

Each of these memory cycles could take hundreds of processor clock cycles to complete, and so in this time the processor would be doing nothing. However, most modern processors employ a {\it cache} to temporarily store commonly accessed memory locations, and so avoid some of the memory cycles. 

\subsection{Registers}
Registers are very small amounts of storage build into a processor. Since they are inside the processor data doesn't need to be transferred over the bus, and so they are very fast. Registers are used instead of the main memory which speeds up program execution.

Each register can only hold one value and each processor will only generally have a few dozen registers (e.g. ARM has sixteen).

\subsection{Instruction Styles}

\subsubsection{One address}
The one address style can only use up to one memory location in each instruction, all other operands must be registers. An example may be:

\[
    R1 \leftarrow R0 + \textrm{\it memory location}
\]

\subsubsection{Load-store}
The load-store style cannot perform operations on memory locations at all. Instead, values from memory must be loaded into a registers before the operation takes place and then the operation can be performed on the registers. Following the operation, the result must be stored back into memory again.

\[
	\begin{split}
	    R1 &\leftarrow \textrm{\it memory location}\\
		R1 &\leftarrow R0 + R1\\
	    \textrm{\it memory location} &\leftarrow R1
    \end{split}
\]

This means that we need extra instructions to do stuff with memory locations:
\begin{enumerate}
	\item \textbf{Load} the value from memory into a register before the operation.
	\item \textbf{Store} the value in the register back to memory after the operation.
\end{enumerate}

For example, the Java code {\it Sum = a + b + c;} would be run as:

\begin{center}
    \begin{tabular}{l l l r}
        R1 & $\leftarrow$ & a & (i.e. load from a)\\
        R2 & $\leftarrow$ & b & (i.e. load from b)\\
        R3 & $\leftarrow$ & R1 + R2 & (i.e. a+b)\\
        R4 & $\leftarrow$ & c & (i.e. load from c)\\
        R5 & $\leftarrow$ & R3 + R4  & (i.e. (a+b)+c)\\
        Sum & $\rightarrow$ & R5 & (i.e. store to sum)\\
    \end{tabular}
\end{center}

You can see that the load-store style favours lots of very simple, very fast instructions.

\section{Lecture 2}
Computers obey programs which are sequences of instructions. Instructions are coded as values in memory. The sequences are held in memory adjacent memory locations. Values in memory can be interpreted as you please, from numbers to text, to images or anything really!

Any given set of binary digits can be read as a decimal number, but not always as text, so values in memory are often represented as numbers for convenience.

\subsection{Assembly Language}
Assembly language is a means of representing machine instructions in a human readable form.

Each type of processor has its own assembly language (since each language is specific to a partial architecture) but they typically have a lot in common:

\begin{itemize}
	\item A mnemonic, that specifies the type of operation
	\item A destination, such as a register or memory location
	\item And one or more sources that may be registers or memory locations.
	\item Possibly with a comment too which will help programmers understand what's happening and aren't interpreted by the assembler.
\end{itemize}

When a program has been written in assembler, it must be {\it assembled} by an {\it assembler} to run it.

\subsection{ARM instructions}

ARM has many instructions but we only need three categories:

\begin{itemize}
	\item Memory operations that move data between the memory and the registers.
	\item Processing operations that perform calculations using value already in registers.
	\item Control flow instructions are used to make decisions, repeat operations etc.
\end{itemize}

\subsection{Transferring data between registers and memory}

Memory operations load a register from the memory or store a register value to the memory.

For example, $a$ into register 1 ($R1 \leftarrow a$) we would write:
{\tt LDR R1, a}

Or to store the value in register 5 into $sum$ ($sum \leftarrow R5$):
{\tt STR R5, sum}

In these examples, $a$ and $sum$ are aliases for the addresses of memory locations.

\subsection{ARM processing instructions}

ARM has many different instructions to perform operations such as addition, subtraction and multiplication.

The syntax for such operations is usually:

\begin{listing}{1}
	[operand]	[destination register]	[register 1]	[register 2]
\end{listing}

For example, to add two numbers together, we might write:

\begin{listing}{1}
	ADD	R2, R0, R1
\end{listing}

This will add the value of R0 to the value of R1 and store it in R2.

\subsection{ARM control instructions}

The most common control instruction is the branch. Similar to \texttt{GOTO} in other languages, a branch will change the PC register (see section~\ref{subsec:pc}) to another value so the order of execution of the program is changed.

% TODO: change (coming up later) to the actual section when it's written

Branches can be made to be conditional by appending a conditional operator (coming up later) on to the command.

The syntax is something like:

\begin{listing}{1}
	B[conditional operator]	[branch name]
\end{listing}

Some examples of different conditional operators are:

\begin{tabularx}{\textwidth}{l X}
	{\bf Command} & {\bf Function}\\
	\texttt{B} & Branches to a different location in the code.\\
	\texttt{BNE} & Branches, but only if the previous condition was false.\\
	\texttt{BEQ} & Branches, but only if the previous condition was true.\\
\end{tabularx}

\subsection{Stored programs and the Program Counter}
\label{subsec:pc}

A computer can make decisions, and choose which instructions to obey next depending upon the results of those decisions. A {\bf Program Counter} (PC) register is used to hold the memory address of the next instruction to be executed. ARM uses register 15 as its PC.

\subsection{Fetch-Execute Cycle}

The processor must first fetch instructions from memory before it can execute them. This is called the fetch-execute cycle, and it involves:

\begin{enumerate}
	\item \textbf{Fetch}: copy the instruction, pointed to by the PC, from memory and set PC to point to the next instruction
	\item \textbf{Execute}:  obey the instruction (exactly as before)
	\item Repeat.
\end{enumerate}

In ARM, the PC starts with a values of \texttt{0x00000000} when the program is initially run. On each cycle of the Fetch-Execute cycle, the PC is incremented by 4, since instructions each occupy 4 memory locations.

\subsection{Decision Making}

In order to make decisions, the computer mustn't just execute instructions one after the other in a linear manner. Instead, branches must be used to change the sequence of instructions to be executed.

In order to perform a conditional branch, we must first perform a compare command to perform the comparison before we do the branch.

\subsubsection{An example}

If we wanted to do a $£1$ discount on a shopping list if the price was over $£20$, we would do the following:

\begin{listing}{1}
		LDR	R0, total	; Load the total price into R0
	
		CMP	R0, #20		; Compare R0 and 20 (the literal)
		BLT	nodiscount	; If the price is too low, then don't discount
		SUB	R0, #1		; Deduct £1
		STR	R0, total	; Store the result back into memory

nodiscount	SVC	2		; Finish

total 		DEFW	25		; Lets say the total is \$25
\end{listing}

\subsection{Allocating memory}

The \texttt{DEFW} (define word) operation puts a value in memory before the program is run. Any define operation is executed before the program is run.

The actual memory location that is used to store the value isn't known to the running program, however, an {\it alias} is attached to the memory location by the programmer and the memory location can be referenced through that.

The syntax for the \texttt{DEFW} command is as follows:

\begin{listing}{1}
myage	DEFW	18
\end{listing}

Where {\tt myage} is the alias and {\tt 18} is the value.

{\tt DEFW} can also be used to define a number of words:

\marginpar{\raggedright The label is associated with the lowest address (i.e. 0)}
\begin{listing}{1}
squares	DEFW	0, 1, 4, 9, 16, 25
\end{listing}

{\tt DEFB} stores a single byte in memory. It is useful for strings such as "hello":

\begin{listing}{1}
hi	DEFB	"hello"
\end{listing}

{\tt DEFS} sets a block of bytes to a set value:

\begin{listing}{1}
reserved_space	DEFS	10, 5
\end{listing}

The above will set 10 bytes to the value '5'.

\section{Lecture 3: Storing values}

\section{Lecture 4: ARM assembly programming}

\subsection{Different types of values}

ARM has the capacity to work with many different types and sizes of values. Each type has a different use case. The main ones are described below:

\begin{tabularx}{\textwidth}{l l X}
	{\bf Name} & {\bf length} & {\bf Use}\\
	Byte & 8 bits & Used for characters\\
	Word & 32 bits & Used for integer es, addresses and instructions\\
\end{tabularx}

There are other types too (such as the halfword and doubleword) but they aren't needed for this module.

ARM processors require that memory locations are aligned. This means that values stored in memory start at specific places. For example, a word address must be a multiple of four.

This means that after a {\tt DEFW} statement, the {\tt ALIGN} command must be called (See ~\ref{subsubsec:align} for more on the {\tt ALIGN} command.).

\subsection{Loading and storing values in memory}

The commands {\tt LDR} and {\tt STR} are used to move values between memory and registers. The commands are detailed in full below:

\begin{tabularx}{\textwidth}{l X}
	{\bf Command} & {\bf Function}\\
	{\tt STR} & Copies the whole (32 bit) register into memory.\\
	{\tt LDR} & Loads a 32 bit word from memory into a register.\\
	{\tt STRB} & Stores a single 8 bit byte into memory from a register.\\
	{\tt LDRB} & Loads a byte from memory into a register. The upper 24 bits of the register are zeroed.\\
\end{tabularx}

\subsection{Endianness}

Endianness is a property of a memory location that defines the order of the bits. There are two types of endianness, {\bf little endian} and {\bf big endian}.

In the word {\tt 0x12345678} there are four bytes:
\begin{itemize}
	\item {\tt 0x12}
	\item {\tt 0x34}
	\item {\tt 0x56}
	\item {\tt 0x78}
\end{itemize}

In little endian, the first byte would be {\tt 0x12} since bits are read from left to right in little endian.

In big endian, the first byte would by {\tt 0x78} since bits are read from right to left in big endian.

This is important when we deciding what the most and least significant bits in a word are. For example, in this instance the {\it lsb} is {\tt 0x12} in little endian, but {\tt 0x78} in big endian.\marginpar{N.b. The least significant bit is the smallest address.}

In this course, little endian is used, though ARM can use either.

\subsection{Addressing memory}

ARM uses 32 bit addresses, so there are $2^{32}$ different bytes that can be addressed in memory (or $\frac{2^{32}}{4}$ different words). However, there is no guarantee that the system on which the program is running will have that much memory available.

\subsection{Instruction encoding}

Each ARM instruction is encoded into a four byte word. The exact meaning of each of the bits varies per instruction.

For example, in the branch instruction, the first four bits specify the condition, the second four bits represent the actual operation to perform (i.e. branch) and the remaining twenty four bits define the memory location of the next instruction to branch to.

However, this presents a problem. We only have twenty four bits with which to define the next location to branch to, which allows us to define $2^24$ different locations. However, there are $2^32$ possible addresses that we could use!

This problem is overcome by treating the 24 bits as an offset to the address of the current instruction. This works since most of the time, the address that is being branched to is fairly close to the current instruction.

In order to be able to branch to addresses before and after the current instruction, we must use two's complement to allow signed integers to be used to specify the offset. This means we can branch to any instruction at an address $\pm 2^{23}$ from the current instruction.

\subsection{Literals}

ARM is able to encode literal values into instructions. This saves time having to access registers or memory in order to perform operations such as arithmetic.

An example is to increment a register:

\begin{listing}{1}
	ADD	R1, R1, #1
\end{listing}

However, ARM only assigns up to 12 bits for a literal value, so we can only have $2^{12}$ values. However, ARM employs a strange method of encoding these values so that more useful values are available (for example, \#512 is allowed, but \#257 isn't).

\subsubsection{Negative literals}

Technically, ARM doesn't support negative literals, however, the assembler will usually be able to find a way to implement them. Some examples are given below:

\marginpar{\raggedright{\tt CMN} is compare negative.\\{\tt MVN} is move not.}
\begin{center}
    \begin{tabular}{l l l r}
        {\tt ADD R1, \#-1} & $\rightarrow$ & {\tt SUB R1, \#1}\\
        {\tt CMP R2, \#-2} & $\rightarrow$ & {\tt CMN R2, \#2}\\
        {\tt MOV R3, \#-3} & $\rightarrow$ & {\tt MVN R3, \#3}\\
    \end{tabular}
\end{center}

\subsection{Supervisor calls}

Supervisor calls are functions implemented by the operating system, not ARM itself. The parameter of an {\tt SVC} call defines it's exact operation.\marginpar{\raggedright SWI is another name for SVC - they do the same thing.}

In this module, the SVC call does the following for each parameter:

\begin{tabularx}{\textwidth}{l X}
	{\tt SVC 0 } & Output a character \\
	{\tt SVC 1 } & Input a character \\
	{\tt SVC 2 } & Stop execution \\
	{\tt SVC 3 } & Output a string \\
	{\tt SVC 4 } & Output an integer \\
\end{tabularx}

\subsection{Pseudo instructions}

The ARM assembler provides some instructions that are translated into sequences of more complicated instructions at the time of assembly for our convenience.

One such instruction is loading a literal into a register. This is done using the {\tt LDR} command as usual, however a literal is used with the '$=$' character instead of a '$\#$'. E.g. to load the value $100$ into register one, we do:

\begin{listing}{1}
	LDR	R1,	=100
\end{listing}

However, this is a pseudo instruction and will be converted by the assembler to:

\begin{listing}{1}
	MOV	R1,	#100
\end{listing}

However, if the number is very large, it becomes:

\begin{listing}{1}
constant	DEFB	100
		LDR	R1, constant
\end{listing}

\subsection{Loading an address into a register}

The {\tt ADR} command loads an address into a register, for example:

\begin{listing}{1}
constant	DEFB	100
		ADR	R1, constant
\end{listing}

Will load the memory address of {\tt constant} into register one.

\subsection{Directives}
Directives are evaluated at the time of assembly.

\subsubsection{DEF commands}

The {\tt DEF\{W,B,S\}} command reserves an amount of memory dependent on the operation used (see the table) and puts an initial value in it.

\begin{tabularx}{\textwidth}{l|X}
	{\bf Command} & {\bf Function}\\ \hline
	{\tt DEFW num} & Reserves a {\it word} of memory and puts the initial value {\tt num} in it.\\ \hline
	{\tt DEFB value} & Reserves {\it byte}(s) of memory and puts the initial value {\tt value} in it. Note that the value can be a string literal, in which case the number of bytes reserved will be equal to the length of the string.\\ \hline
	{\tt DEFS size, fill} & Reserves a {\it block} of memory of {\tt size} bytes and initialises them with the value {\tt fill}. \\ \hline	
\end{tabularx}

\subsubsection{Align}
\label{subsubsec:align}
The align command leaves as many blank bytes as needed so that the next item in memory will start at a word boundary (a multiple of 4).

\subsubsection{Entry}
Sets the PC at the start of the program (i.e. where the program should start from)

\subsubsection{EQU}
Allows you to name a literal, which can go a long way to making the code more maintainable. We could define the literal $18$ as $drinking\_age$:

\begin{listing}{1}
drinking_age	EQU 	#18
		; Check the person is over 18
		CMP 	R1, #drinking_age
		BLT	too_young
\end{listing}

\section{Lecture 5: Arithmetic}

\subsection{Making good use of registers}

Registers are a precious resource when programming on ARM. When writing software to evaluate expressions, it's often tempting to load all the variables into registers first, and then perform the arithmetic in separate registers like so:

\begin{listing}{1}
	; a = b + c + d
	LDR 	R1, b
	LDR 	R2, c
	LDR 	R3, d
	ADD 	R4, R1, R2
	ADD 	R5, R4, R3
	STR 	R5, a
\end{listing}

However, this is pointless - the values in the registers {\tt R4} and {\tt R5} aren't going to be needed again, so we may as well do:

\begin{listing}{1}
; a = b + c + d
LDR 	R1, b
LDR 	R2, c
LDR 	R3, d
ADD 	R1, R1, R2
ADD 	R1, R1, R3
STR 	R1, a
\end{listing}

But, we can optimise even further here. Instead of loading all the variables into registers before we do arithmetic, we can save a register and load only the ones we need before each {\tt ADD} instruction:

\begin{listing}{1}
; a = b + c + d
LDR 	R1, b
LDR 	R2, c
ADD 	R1, R1, R2
LDR 	R2, d
ADD 	R1, R1, R2
STR 	R1, a
\end{listing}

Sometimes, it's useful to re-order an arithmetic expression so it can be implemented using less registers. This can often be achieved by increasing the nesting of brackets in an expression such as this:

\[
	(b - e) + (c * d) = ((c * d) + b - e)
\]

Though these expressions are both equal, the right hand side will use a register less in ARM code, since each instruction can be executed sequentially, however the left hand side requires two expressions to be evaluated (and stored in a total of three registers) and then both expressions added together.

\subsection{Using literals in expressions}

If there is a literal in the expression you want to evaluate, then it's possible to use a literal instead of a register. For example, these two programs will end up with the same answer in {\tt R0} but the one on the right uses less registers:

% Split the page into two for side-by-side comparison
\begin{minipage}[t]{0.5\textwidth}
	\begin{listing}{1}
	; (a + 5) * b
	LDR	R0, 5
	LDR	R1, a
	ADD	R0, R0, R1
	LDR	R1, b
	MUL	R0, R0, R1

five	DEFW	5
	\end{listing}
\end{minipage}
\begin{minipage}[t]{0.5\textwidth}
	\begin{listing}{1}
	; (a + 5) * b
	LDR	R0, a
	ADD	R0, R0, #5
	LDR	R1, b
	MUL	R0, R0, R1



	\end{listing}
\end{minipage}

Literals can be any expression that the assembler can evaluate, for example, the following are all valid:\marginpar{\raggedright Note that {\tt MUL} cannot use literals. To get around this, first {\tt MOV} the literal into a register and then multiply.}

\begin{verbatim}
	ADD	R0, R0, #(1 + 2)
\end{verbatim}

% TODO: Check this
\begin{verbatim}
	ADD	R0, R0, #-2
\end{verbatim}

% TODO: Check this
\begin{verbatim}
	ADD	R0, R0, #(2 - 1)
\end{verbatim}

\subsection{Status flags}

ARM has some 1-bit status flags that are set after a {\tt CMP} instruction as shown below:

\begin{tabular}{l|l}
	Flag & Meaning\\ \hline
	Negative & Previous result was negative\\ \hline
	Zero & Previous result was zero\\ \hline
	Carry & Previous add or subtract generated a carry\\ \hline
	Overflow & The previous add or subtract overflowed and went out of range\\ \hline
\end{tabular}

You can get any data operation to alter the flags by appending {\tt S} to the instruction. For example:

\begin{verbatim}
	SUBS	R0, R1, R2
\end{verbatim}

The above command will subtract {\tt R2} from {\tt R1} and store the result in {\tt R0}, but it will also set the flags according to the value of {\tt R0}. For example, if the value in {\tt R0} was negative after the operation, the {\tt Negative} flag would be set.

\subsection{Other useful arithmetic commands}

The {\tt RSB} command is reverse subtract, and is useful for negating a literal:

\begin{verbatim}
	RSB	R1, R0, #0; R1 = 0 - R0 = -R0
\end{verbatim}

The {\tt MLA} command is multiply and add. It can only use registers as operands.

\begin{verbatim}
	MLA	R1, R2, R3, R4 ; R1 = (R2 * R3) + R4
\end{verbatim}

\section{Lecture 6: If and While}

\subsection{If statements in ARM}

Given an if statement written in Java such as this:

\begin{listing}{1}
if(condition)
{
    actionStatement;
}
\end{listing}

How would we convert that into ARM assembly? The best way is to do the following:

\begin{enumerate}

	\item Check to see if the condition is false

	\item If it is, then branch to the end of the if statement

	\item Otherwise, perform the action statement

\end{enumerate}

An example implementation may be:

\begin{listing}{1}
	CMP 	R1, R2  	; Compare two registers
	BGE 	endif		; The condition
	MOV 	R1, #0 	; Whatever the action statement may be
endif
\end{listing}

Note that it is often easier to implement the inverse of some comparisons. For example, if we were evaluating {\tt (a >= b)} we could do either of these:

\begin{itemize}
	\item 
	\begin{enumerate}
		\item Check whether {\tt a} is greater than {\tt b}
		\item Check whether {\tt a} is equal to {\tt b}
		\item Work out how to branch away if both are false
	\end{enumerate}
	\item 
	\begin{enumerate}
		\item Inverse the comparison and check if {\tt a} is less than {\tt b}
		\item Branch away if it is
	\end{enumerate}
\end{itemize}

\subsection{If else statements}

If else statements are much like if statements, except that if the condition is
false then you branch to the else action, and if the condition is true, then you
branch to after the else statement once you've executed the action. Here's an
example:

Lets implement {\tt if(a==b) { a += 1;} else { b += 1; }}:

\begin{listing}{1}
	LDR 	R0, a
	LDR 	R1, b
	CMP 	R0, R1 	; Compare
	BNE 	else	;If they aren't equal
	ADD 	R0, R0, #1
	B 	end
else 	ADD 	R1, R1, #1
end
\end{listing}

\subsection{While statements}

Implementing a while statement in ARM assembler is very similar to implementing
an if statement, except after you have executed the action statement, you branch
back to the initial condition again, like so:\marginpar{Note that if the code in
your while loop is being executed repeatedly, then it's probably worth
optimising it!}

\begin{listing}{1}
start	CMP 	R1, R2  	; Compare two registers
	BGE 	endif		; The condition
	ADD 	R1, R1, #1 	; Whatever the action statement may be
	B	start 		; Branch back to the start
endif
\end{listing}

In ARM, we can make {\it any} instruction have a conditional code on it.
Consequently, we can get rid of a branch instruction, like so:

\begin{listing}{1}
start	CMP 	R1, R2  	; Compare two registers
	ADDLT 	R1, R1, #1 	; Add only if the flag is less than
	BLT	start 		; Branch back to the start
endif
\end{listing}

You can compare the result of an arithmetic instruction with zero by appending
{\tt S} to the instruction like so:

%TODO: Check this
\begin{listing}{1}
start	ADDS 	R0, #1
	BNE 	start
endif
\end{listing}

This will keep adding {\tt 1} to {\tt R0} until it reaches 0. This is often
useful when translating for loops that count up to a number. Instead of counting
up, you can count down using the {\tt SUBS} instruction and only iterate if the
result isn't zero.

\section{Lecture 7: Addresses and Addressing}
When a processor references memory it needs to produce an address.

The address needs the same number of bits as the memory address. i.e. 32 in ARM

addressing modes - mechanisms for generating addresses

\subsection{Direct Addressing}
Direct addressing is a mode where the address is simply contained within the instruction.

This requires an instruction longer than the address size which is a problem because ARMs maximum bit length is 32.

So far, we assumed that direct addressing uses LDR/STR instructions, for example:

\begin{center}
    \begin{tabular}{l l l}
        LDR & R0, & b\\
        LDR & R1, & c\\
        ADD & R0, & R0, R2\\
        STR & R0, & a \\
    \end{tabular}
\end{center}

This looks like direct addressing but on ARM it's 'faked' by the assembler as a pseudo-instruction

\subsubsection{Problems with direct addressing}
ARM: both instructions and addresses are 32 bits, but the instruction also specifies operation so it can't contain every possible address.

Solution: allow a register to contain an address, use the address in the register to do loads and stores.

This is {\bf Register Indirect Addressing}

\subsection{Register Indirect Addressing}
The address is held in the register

It takes only a few bits to select a register (4 bits in the case of ARM R0-R15)

A register can (typically) hold an arbitrary address (32 bits in the case of ARM)

ARM has register indirect addressing

\paragraph{Example}
loading a register from a memory location: LDR R0, b

Could be done using register indirect addressing:

\begin{center}
    \begin{tabular}{l l l l}
        ADR & R2, & b & move the {\bf address} of b into R2\\
        LDR & R0, & [R2] & use address in R2 to fetch the {\bf value} of b\\
    \end{tabular}
\end{center}

This is still a bit limited - addresses are:

\begin{itemize}
  \item range limited (within ADR 'instruction')
  \item fixed
\end{itemize}

but:

\begin{itemize}
  \item ADRL pseudo-op allows larger range (at a price)
  \item having addresses a variable once it is often used again
  \item variable are usually 'near' each other
\end{itemize}

\subsubsection{Address Arithmetic}
We can operate on registers, so we can:

\begin{itemize}
  \item store/load/move addresses
  \item do arithmetic to calculate addresses
\end{itemize}

Rather than use e.g. extra ADD instructions, we often use {\bf Base + Offset Addressing} - address addition done within the operand.

We have actually been using this all along: Base = PC register.

\subsection{Offset Addressing}
In offset addressing the address is calculated from a register value and a number.

The register specifier is just a few bits, The offset can be 'fairly small'.

With one register 'pointer' any of several variables in nearby addresses may be addressed.

ARM allows offsets of 12 bits in LDR/STR

These bits can be added or subtracted, for example:

\begin{center}
    \begin{tabular}{l l l}
        {\tt LDR} & R0, & [R1, \#8] \\
        STR & R3, & [R6, \#-0x240]\\
        LDR & R7, & [R2, \#short-constant]
    \end{tabular}
\end{center}

This provides a range of $\pm$ ~4 kilobytes around a 'base' register

In practice this method is adequate for most purposes. 

\section{Lecture 8: Strings, bit shifts, rotations and tables}

\subsection{Working with Strings}

A String is just a list of bytes where each byte represents a character. The
last byte in the list is the null byte which contains the value {\tt 0}.

\subsubsection{Loading a String}

In order to load the String into a register, the {\tt ADRL} command must be
used, for example:

\begin{listing}{1}
msg	DEFB 	"My message", 0
	ALIGN

	ADRL 	R0, msg
	SVC 	3
\end{listing}

\subsubsection{Finding the length of a String}

In order to find the length of a String, we need only to loop over each byte in
the String until we get to the null byte, and add up how many iterations we've
done as we go along:

\begin{listing}{1}
	ADRL	R1, message
	MOV 	R2, #0
count 	LDRB 	R0, [R1, R2]
	CMP 	R0, #0
	ADDNE 	R2, R2, #1
	BNE 	count
	STR 	R2, length
\end{listing}

\marginpar{\vspace{-6em}Here, we use {\tt R1} to store the message, {\tt R0} to read each
character, and {\tt R2} to keep the count.}

\subsubsection{Getting the index of a character in a String}

In order to do the equivalent of {\tt String.indexOf(character)}, we can do
something similar to finding the length of the String, but we only need to loop
until we get to the character we're looking for.

\begin{listing}{1}
	ADRL	R1, message
	LDRB	R2, character
count 	LDRB 	R0, [R1] #1
	CMP 	R0, #0
	BEQ 	end
	CMP 	R0, R2
	BNE 	count
end 	ADRL 	R0, message
	SUB 	R1, R1, R0
	SUB 	R1, R1, #1
	STR 	R0, index
\end{listing}

\marginpar{\vspace{-10em}Note how this snippet has an optimisation to use one less
register during the looping process than the string length snippet does. It
only uses one register to loop over the string and then works out the number of
times it's looped after the character has been found.}

\subsection{Bit shifting and rotations}

Shift operations move all the bits in a word in one direction or another. For
example:

\begin{center}
	\begin{tabular}{|l|c|}
		\hline
		{\bf Shift direction} & {\bf Resultant word}\\ \hline
		No shift & {\tt 10011011}\\ \hline
		Left shift & {\tt 00110110}\\ \hline
		Right shift & {\tt 01001101}\\ \hline
	\end{tabular}
\end{center}

\marginpar{Shifting to the left is like multiplying by two, and shifting to the
right is like dividing by two.}

You might have noticed that a zero is appended to whatever side the bits are
moving away from in order to ensure that the word is still the same number of
bits as before.

Rotation operations are very similar to shift operations, except instead of
padding the word with zeroes, the bit that was lost is appended to the other
side of the word:

\begin{center}
	\begin{tabular}{|l|c|}
		\hline
		{\bf Rotation direction} & {\bf Resultant word}\\ \hline
		No rotation & {\tt 10011011}\\ \hline
		Left rotation & {\tt 00110111}\\ \hline
		Right rotation & {\tt 11001101}\\ \hline
	\end{tabular}
\end{center}

ARM has four different operations for shifting and rotations:

\begin{center}
	\begin{tabularx}{0.8\textwidth}{|l|l|X|}
		\hline
		{\bf Mnemonic} & {\bf Meaning} & {\bf Function}\\ \hline
		{\tt LSL n} & Logical shift left & Shifts left by n bits. Any bits that are lost are zeroed.\\ \hline
		{\tt LSR n} & Logical shift right &  Shifts right by n bits. Any bits that are lost are zeroed.\\ \hline
		{\tt ASR n} & Arithmetic shift right & Shifts right by n bits. Any bits that are lost are set as the sign bit (to preserve the signed bit).\\ \hline
		{\tt ROR n} & Rotate Right & Rotates right by n bits.\\ \hline
	\end{tabularx}
\end{center}

\subsection{Accessing a row in a table}

We can use bit shifts to access a row in a table:

\begin{listing}{1}
	ADRL 	R1, table
	LDR 	R2, [R1, R0, LSL #2]

table 	DEFW 	0
	DEFW 	3
	DEFW 	6
	DEFW 	9
	DEFW 	12
	DEFW 	15
	DEFW 	18
\end{listing}

This snippet will allow us to access the row with an index stored in {\tt R0},
so if {\tt R0} was {\tt 2} then the output in {\tt R2} would be {\tt 6}.

\section{Lecture 9: Stacks}
\section{Lecture 10: Methods, parameters, variables and stacks}

\end{document}